diff --color -ruN a/src/window.c b/src/window.c
--- a/src/window.c	2025-11-25 20:16:25
+++ b/src/window.c	2025-11-25 20:16:25
@@ -11,7 +11,11 @@
 #include "window.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <unistd.h>
 
 #include <pthread.h>
 
@@ -226,6 +230,14 @@
      */
     struct vec2i cursor_pos;
 
+    /**
+     * @brief Framebuffer file descriptor and memory mapping for direct FB access.
+     */
+    int fb_fd;
+    void *fb_mem;
+    long fb_screensize;
+    struct fb_var_screeninfo fb_vinfo;
+
     int (*push_composition)(struct window *window, struct fl_layer_composition *composition);
     struct render_surface *(*get_render_surface)(struct window *window, struct vec2i size);
 
@@ -1681,14 +1693,82 @@
 #endif
     window->deinit = dummy_window_deinit;
     window->set_cursor_locked = dummy_window_set_cursor_locked;
+    
+    // Initialize FB fields
+    window->fb_fd = -1;
+    window->fb_mem = MAP_FAILED;
+    window->fb_screensize = 0;
+    
     return window;
 }
 
 static int dummy_window_push_composition(struct window *window, struct fl_layer_composition *composition) {
     window_lock(window);
 
-    /// TODO: Maybe allow to export the layer composition as an image, for testing purposes.
-    (void) composition;
+    struct render_surface *surface = window->render_surface;
+    if (surface == NULL) {
+        window_unlock(window);
+        return 0;
+    }
+    
+    struct egl_gbm_render_surface *egl_surface = CAST_EGL_GBM_RENDER_SURFACE(surface);
+    
+    // Initialize framebuffer if not already done
+    if (window->fb_fd == -1) {
+        window->fb_fd = open("/dev/fb0", O_RDWR);
+        if (window->fb_fd == -1) {
+            LOG_ERROR("Error: cannot open framebuffer device. open: %s\n", strerror(errno));
+            window_unlock(window);
+            return -1;
+        }
+        
+        if (ioctl(window->fb_fd, FBIOGET_VSCREENINFO, &window->fb_vinfo)) {
+            LOG_ERROR("Error reading variable information. ioctl: %s\n", strerror(errno));
+            close(window->fb_fd);
+            window->fb_fd = -1;
+            window_unlock(window);
+            return -1;
+        }
+        
+        window->fb_screensize = window->fb_vinfo.yres_virtual * window->fb_vinfo.xres_virtual * window->fb_vinfo.bits_per_pixel / 8;
+        window->fb_mem = mmap(0, window->fb_screensize, PROT_READ | PROT_WRITE, MAP_SHARED, window->fb_fd, 0);
+        if (window->fb_mem == MAP_FAILED) {
+            LOG_ERROR("Error: failed to map framebuffer device to memory. mmap: %s\n", strerror(errno));
+            close(window->fb_fd);
+            window->fb_fd = -1;
+            window_unlock(window);
+            return -1;
+        }
+        
+        LOG_DEBUG("Framebuffer initialized: %dx%d, %dbpp\n", window->fb_vinfo.xres, window->fb_vinfo.yres, window->fb_vinfo.bits_per_pixel);
+    }
+    
+    size_t buffer_size = (size_t)(window->view_size.x * window->view_size.y * 4);
+    void *buffer = malloc(buffer_size);
+    if (buffer == NULL) {
+        LOG_ERROR("Error: failed to allocate buffer for pixel readback.\n");
+        window_unlock(window);
+        return -1;
+    }
+    
+    egl_gbm_render_surface_read_pixels(egl_surface, buffer, buffer_size);
+    
+    int width = (int)window->view_size.x;
+    int height = (int)window->view_size.y;
+    int stride = window->fb_vinfo.xres_virtual * (window->fb_vinfo.bits_per_pixel / 8);
+    
+    // Copy row by row, flipping Y axis because OpenGL is bottom-up and FB is top-down
+    for (int y = 0; y < height; y++) {
+        void *src_row = buffer + (y * width * 4);
+        void *dst_row = (char *)window->fb_mem + ((height - 1 - y) * stride);
+        
+        // Ensure we don't write out of bounds
+        if ((char *)dst_row + (width * 4) <= (char *)window->fb_mem + window->fb_screensize) {
+             memcpy(dst_row, src_row, width * 4);
+        }
+    }
+    
+    free(buffer);
 
     window_unlock(window);
 
@@ -1800,6 +1880,17 @@
 #else
         UNREACHABLE();
 #endif
+    }
+
+    // Cleanup FB resources
+    if (window->fb_mem != MAP_FAILED) {
+        munmap(window->fb_mem, window->fb_screensize);
+        window->fb_mem = MAP_FAILED;
+    }
+    
+    if (window->fb_fd != -1) {
+        close(window->fb_fd);
+        window->fb_fd = -1;
     }
 
     window_deinit(window);
