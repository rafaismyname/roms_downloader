diff --git a/src/flutter-pi.c b/src/flutter-pi.c
index 1234567..89abcdef 100644
--- a/src/flutter-pi.c
+++ b/src/flutter-pi.c
@@ -1,5 +1,8 @@
 #define _GNU_SOURCE
 #include <stdio.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <linux/fb.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdbool.h>
@@ -50,6 +53,11 @@
 #include <flutter_embedder.h>
 
 
+// FBDEV Globals
+static int fbfd = 0;
+static struct fb_var_screeninfo vinfo;
+static struct fb_fix_screeninfo finfo;
+static char *fbp = 0;
+
 struct flutterpi flutterpi;
 
 static bool on_make_current(void *userdata) {
@@ -68,6 +76,44 @@ static bool on_make_resource_current(void *userdata) {
     return true;
 }
 
+static bool on_software_present(void *userdata, const void *allocation, size_t row_bytes, size_t height) {
+    if (!fbp) return false;
+
+    // Simple memcpy for now. 
+    // WARNING: Assumes Flutter outputs 32-bit RGBA and FB is 32-bit ARGB/RGBA.
+    // If colors are wrong, we might need swizzling.
+    // If FB is 16-bit (RGB565), we need conversion.
+    
+    // Copy line by line to handle stride differences if any, 
+    // but for full screen updates, a single memcpy might work if strides match.
+    
+    // Calculate total bytes to copy
+    size_t bytes_to_copy = row_bytes * height;
+    size_t fb_size = vinfo.yres_virtual * finfo.line_length;
+
+    if (bytes_to_copy > fb_size) {
+        bytes_to_copy = fb_size;
+    }
+
+    memcpy(fbp, allocation, bytes_to_copy);
+    
+    return true;
+}
+
+static void init_fbdev() {
+    fbfd = open("/dev/fb0", O_RDWR);
+    if (fbfd == -1) {
+        perror("Error: cannot open framebuffer device");
+        exit(1);
+    }
+    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo) == -1) {
+        perror("Error reading fixed information");
+        exit(2);
+    }
+    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo) == -1) {
+        perror("Error reading variable information");
+        exit(3);
+    }
+    long screensize = vinfo.yres_virtual * finfo.line_length;
+    fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);
+    if ((int)fbp == -1) {
+        perror("Error: failed to map framebuffer device to memory");
+        exit(4);
+    }
+    printf("FBDEV Initialized: %dx%d, %dbpp\n", vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);
+}
+
 static bool on_present(void *userdata) {
     return true;
 }
@@ -200,6 +246,10 @@ int main(int argc, char **argv) {
     
     // ... (Argument parsing would go here) ...
 
+    // FORCE FBDEV INIT
+    printf("Forcing FBDEV mode...\n");
+    init_fbdev();
+
     // Configure Flutter Renderer
     FlutterRendererConfig config = {0};
-    config.type = kOpenGL;
-    config.open_gl.struct_size = sizeof(FlutterOpenGLRendererConfig);
-    config.open_gl.make_current = on_make_current;
-    config.open_gl.clear_current = on_clear_current;
-    config.open_gl.present = on_present;
-    config.open_gl.fbo_callback = on_fbo_callback;
-    config.open_gl.make_resource_current = on_make_resource_current;
+    
+    // SWITCH TO SOFTWARE RENDERING
+    config.type = kSoftware;
+    config.software.struct_size = sizeof(FlutterSoftwareRendererConfig);
+    config.software.surface_present_callback = on_software_present;
 
     FlutterProjectArgs args = {0};
     args.struct_size = sizeof(FlutterProjectArgs);
@@ -220,10 +270,12 @@ int main(int argc, char **argv) {
     
     // Bypass DRM/GBM init
-    // ok = setup_paths(&flutterpi);
-    // if (!ok) return 1;
-    // ok = setup_config(&flutterpi);
-    // if (!ok) return 1;
+    // We are hacking this in, so we skip the standard setup that requires DRM
     
     // Run the engine
     FlutterEngineResult result = FlutterEngineRun(FLUTTER_ENGINE_VERSION, &config, &args, &flutterpi, &flutterpi.engine);
